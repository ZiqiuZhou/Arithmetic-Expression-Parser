
#include <vector>
#include <cstddef>      // for ptrdiff_t
#include <utility>      // for move(), pair<>
#include <iomanip>      // for quoted()
#include <iostream>     // for istream
#include <stdexcept>    // for runtime_error
#include <functional>   // for reference_wrapper<>
#include <string_view>

//#include <fmt/core.h>  // for format()


// Define this macro to enable debug output.
//#define BOOST_SPIRIT_X3_DEBUG


// Disable some Visual C++ warnings for Boost.Spirit X3.
#ifdef _MSC_VER
# pragma warning( push )
# pragma warning( disable: 4127 )  // conditional expression is constant
# pragma warning( disable: 4459 )  // declaration of '%s' hides global declaration
# pragma warning( disable: 4828 )  // The file contains a character starting at offset %x that is illegal in the current source character set
#endif // _MSC_VER

#include <boost/spirit/home/x3.hpp>
#include <boost/spirit/home/x3/char/unicode.hpp>
#include <boost/spirit/home/x3/support/ast/position_tagged.hpp>

#include <boost/fusion/include/adapt_struct.hpp>

#ifdef _MSC_VER
# pragma warning( pop )
#endif // _MSC_VER

#include "unicode.h"
#include "expression.h"
#include "boost-spirit-helpers.h"


// Parser based on "Boost Matheval", https://github.com/hmenke/boost_matheval, by Henri Menke.
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


namespace asc::cpp_practice_ws20::ex08 {

    namespace x3 = boost::spirit::x3;


    struct ASTOperand
    {
        expr::Expression e;

        // Spirit X3 requires AST types to have a default constructor, otherwise this wouldn't need to exist.
        ASTOperand()
            : e(expr::RationalConstant{ 0 })
        {
        }
        ASTOperand(expr::Expression _expr)
            : e(std::move(_expr))
        {
        }
        ASTOperand(int i)
            : e(expr::RationalConstant{ i })
        {
        }
        ASTOperand(double d)
            : e(expr::RealConstant{ d })
        {
        }
        ASTOperand(expr::NamedConstant nc)
            : e(nc)
        {
        }
        ASTOperand(std::u32string const& v)
            : e(expr::Variable{ to_utf8(v) })
        {
        }
    };

    struct ASTFunctionExpression : x3::position_tagged
    {
        std::u32string f;
        std::vector<ASTOperand> args;

        operator ASTOperand()&&
        {
            if (f == U"sin") return asUnaryFunctionExpression(expr::Sin{ });
            if (f == U"cos") return asUnaryFunctionExpression(expr::Cos{ });
            if (f == U"tan") return asUnaryFunctionExpression(expr::Tan{ });
            if (f == U"arcsin") return asUnaryFunctionExpression(expr::ArcSin{ });
            if (f == U"arccos") return asUnaryFunctionExpression(expr::ArcCos{ });
            if (f == U"arctan") return asUnaryFunctionExpression(expr::ArcTan{ });
            if (f == U"exp") return asUnaryFunctionExpression(expr::Exp{ });
            if (f == U"log")
            {
                if (args.size() == 1) return asUnaryFunctionExpression(expr::Log{ });
                if (args.size() == 2) return asBinaryFunctionExpression(expr::LogBase{ });
                throw SemanticError("expects 1 or 2 arguments.", *this);
            }
            if (f == U"sqrt") return asUnaryFunctionExpression(expr::Sqrt{ });
            if (f == U"pow") return asBinaryFunctionExpression(expr::Pow{ });
            throw SemanticError("Unknown function.", *this);
        }

    private:
        void
            checkArity(std::size_t expected)
        {
            if (args.size() != expected)
            {
                throw SemanticError("Function arguments number incorrect.", *this);
            }
        }
        ASTOperand
            asUnaryFunctionExpression(expr::UnaryFunction func)
        {
            checkArity(1);
            return expr::Expression{
                expr::UnaryFunctionExpression{
                    .f = func,
                    .x = std::move(args[0]).e
                }
            };
        }
        ASTOperand
            asBinaryFunctionExpression(expr::BinaryFunction func)
        {
            checkArity(2);
            return expr::Expression{
                expr::BinaryFunctionExpression{
                    .f = func,
                    .x = std::move(args[0]).e,
                    .y = std::move(args[1]).e
                }
            };
        }
    };

    struct ASTBinaryOperandExpression
    {
        expr::BinaryFunction op;
        ASTOperand rhs;
    };

    struct ASTExpression
    {
        ASTOperand lhs;
        std::vector<ASTBinaryOperandExpression> operands;

        expr::Expression
            get()&&
        {
            auto expr = std::move(lhs).e;
            for (auto&& operand : operands)
            {
                expr = expr::Expression(expr::BinaryFunctionExpression{
                    .f = std::move(operand).op,
                    .x = std::move(expr),
                    .y = std::move(operand).rhs.e
                    });
            }
            return expr;
        }
        operator ASTOperand()
        {
            return std::move(*this).get();
        }
    };

    struct ASTUnaryOperatorExpression
    {
        expr::UnaryFunction f;
        ASTOperand arg;

        operator ASTOperand()&&
        {
            return expr::Expression(expr::UnaryFunctionExpression{
                .f = std::move(f),
                .x = std::move(arg.e)
                });
        }
    };


} // namespace asc::cpp_practice_ws20::ex08


BOOST_FUSION_ADAPT_STRUCT(asc::cpp_practice_ws20::ex08::ASTFunctionExpression, f, args)
BOOST_FUSION_ADAPT_STRUCT(asc::cpp_practice_ws20::ex08::ASTBinaryOperandExpression, op, rhs)
BOOST_FUSION_ADAPT_STRUCT(asc::cpp_practice_ws20::ex08::ASTExpression, lhs, operands)
BOOST_FUSION_ADAPT_STRUCT(asc::cpp_practice_ws20::ex08::ASTUnaryOperatorExpression, f, arg)


namespace asc::cpp_practice_ws20::ex08 {

    namespace parser {


        struct utf32 : boost::spirit::char_encoding::unicode
        {
            using char_type = char32_t;
        };

        template <typename T> using symbols = x3::symbols_parser<utf32, T>;


        // Symbol definitions

        struct NamedConstantParser : symbols<expr::NamedConstant>
        {
            NamedConstantParser()
            {
                add(U"e", { expr::NamedConstant::e });
                add(U"дл", { expr::NamedConstant::pi });
                add(U"pi", { expr::NamedConstant::pi });
            }
        } namedConstant;

        struct UnaryOperatorParser : symbols<expr::UnaryFunction>
        {
            UnaryOperatorParser()
            {
                add(U"+", expr::Positive{ });
                add(U"-", expr::Negative{ });
            }
        } unaryOperator;

        struct BinaryAdditiveOperatorParser : symbols<expr::BinaryFunction>
        {
            BinaryAdditiveOperatorParser()
            {
                add(U"+", expr::Add{ });
                add(U"-", expr::Subtract{ });
            }
        } binaryAdditiveOperator;

        struct BinaryMultiplicativeOperatorParser : symbols<expr::BinaryFunction>
        {
            BinaryMultiplicativeOperatorParser()
            {
                add(U"*", expr::Multiply{ });
                add(U"/", expr::Divide{ });
            }
        } binaryMultiplicativeOperator;

        struct BinaryPowerOperatorParser : symbols<expr::BinaryFunction>
        {
            BinaryPowerOperatorParser()
            {
                add(U"^", expr::Pow{ });
                add(U"**", expr::Pow{ });
            }
        } binaryPowerOperator;


        // Rule declarations

        auto const expression = x3::rule<class ExpressionId, ASTExpression>{ "expression" };
        auto const binaryAdditiveExpression = x3::rule<class AdditiveExpressionId, ASTExpression>{ "additive" };
        auto const unaryAdditiveExpression = x3::rule<class UnaryAdditiveExpressionId, ASTOperand>{ "unary" };
        auto const unaryOperatorExpression = x3::rule<class UnaryOperatorExpressionId, ASTUnaryOperatorExpression>{ "unary" };
        auto const binaryMultiplicativeExpression = x3::rule<class MultiplicativeExpressionId, ASTExpression>{ "multiplicative" };
        auto const factorExpression = x3::rule<class FactorExpressionId, ASTExpression>{ "factor" };
        auto const primaryExpression = x3::rule<class PrimaryExpressionId, ASTOperand>{ "primary" };
        auto const functionExpression = x3::rule<class FunctionExpressionId, ASTFunctionExpression>{ "function" };
        auto const function = x3::rule<class FunctionId, std::u32string>{ "function" };
        auto const variable = x3::rule<class VariableId, std::u32string>{ "variable" };


        // Rule definitions

        auto const expression_def =
            binaryAdditiveExpression;

        auto const binaryAdditiveExpression_def =
            unaryAdditiveExpression >> *(binaryAdditiveOperator > unaryAdditiveExpression);

        auto const unaryAdditiveExpression_def =
            unaryOperatorExpression
            | as<ASTOperand>(binaryMultiplicativeExpression);

        auto const unaryOperatorExpression_def =
            unaryOperator > binaryMultiplicativeExpression;

        auto const binaryMultiplicativeExpression_def =
            factorExpression >> *(binaryMultiplicativeOperator > as<ASTOperand>(factorExpression));

        auto const factorExpression_def =
            primaryExpression >> *(binaryPowerOperator > as<ASTOperand>(factorExpression));

        auto const functionExpression_def =
            function >> ('(' > (expression % ',') > ')');

        auto const function_def =
            x3::raw[x3::lexeme[x3::alpha >> *(x3::alnum | '_')]];

        auto const variable_def =
            x3::raw[x3::lexeme[x3::alpha >> *(x3::alnum | '_')]];

        auto const double_ = x3::real_parser<double, x3::strict_real_policies<double>>{ };

        auto const primaryExpression_def =
            double_
            | x3::int_
            | ('(' > expression > ')')
            | functionExpression
            | namedConstant
            | variable;

        BOOST_SPIRIT_DEFINE(
            expression,
            binaryAdditiveExpression,
            unaryAdditiveExpression,
            unaryOperatorExpression,
            binaryMultiplicativeExpression,
            factorExpression,
            primaryExpression,
            functionExpression,
            function,
            variable)


            struct AnnotatePosition
        {
            template <typename T, typename Iterator, typename Context>
            void
                on_success(Iterator const& first, Iterator const& last, T& ast, Context const& context)
            {
                auto& position_cache = x3::get<PositionCacheTag>(context).get();
                position_cache.annotate(ast, first, last);
            }
        };

        class FunctionExpressionId : public AnnotatePosition { };


    } // namespace parser

    namespace expr {


        Expression
            Expression::parse(std::string_view str)
        {
            x3::ascii::space_type space;
            auto theParser = parser::expression;
            auto result = ASTExpression{ };
            parseAndReportErrors(str, theParser, space, result);
            return std::move(result).get();
        }


    } // namespace expr
}

